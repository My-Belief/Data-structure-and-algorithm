2021考研的第二章！！！冲冲冲

[Toc]
# 第二章  线性表
【考纲的内容】
	（一）线性表的定义和基本操作
	（二）线性表的实现
	（三）顺序存储：链式存储；线性表的应用
【知识框架】

​	![知识框架](%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6.png)

## 2.1 线性表的定义和基本操作
### 2.1.1  线性表的定义
		线性表是具有相同数据类型的n(你>=0)个数据元素的有限序列，其中n为表长，当n=0时，线性表是一个空表。若用L命名线性表，则其一般表示表示为：
			L=(a1,a2,...,ai,a(i+1),...,an)
		式中，a1是唯一的“第一个”数据元素，又称表头元素；an是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素以外，每个元素有且仅有一个直接前驱。除最后一个元素以外，每个元素有且仅有一个直接后驱。根据上述的定义中我们可以得出线性表的如下特点：
	    1.表中元素的个数有限
	    2.表中元素具有逻辑上的顺序性，表中元素有其先后次序
	    3.表中元素都是数据元素，每个元素都是单个元素
	    4.表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间
	    5.表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容
		注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。

### 2.1.2  线性表的基本操作
		一个数据结构的基本操作是指其最核心，最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：
		InitList(&L):初始化表。构建一个空的线性表
		Length(L):求表长。返回线性表L的长度，即L中数据元素的个数
		LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素
		GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值
		ListInsert(&L,i,e):插入操作。在表L中的第i个位置上插入指定元素e
		ListDelete(&L,i,&e):删除操作。输出表L中第i个位置的元素,并用e返回删除的元素
		PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值
		Empty(L):判空操作。若L为空表，则返回true，否则返回false
		DestroyList(&L):销毁操作。毁掉线性表，并释放线性表L所占用的内存空间
## 2.2  线性表的顺序表示

### 2.2.1  顺序表的定义
		线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储子线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第一个元素存储在线性表的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素ai在线性表中的位序。因为，顺序表的特点是表中元素的逻辑顺与其物理顺序相同。
		假设线性表L存储的起始位置为LOC(A),sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序如下图所示：

![线性表的顺序结构](%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.png)
	==注意:==线性表中的元素的位序是从一开始的，而数组中元素的下标谁从0开始的
		
假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：

```c++
	#define MaxSize 50   //定义线性表的最大长度
	typedef struct{		
		ElemType data[MaxSize];  //顺序表的元素
		int length;				//顺序表的长度
	}SqList;					//顺序表的类型定义
```
		在上面的写法中是静态分配的，当然一堆数组也可以动态的进行分配。在静态分配时会产生一些问题，由于数组的大小和空间已经固定。一旦空间占满，再加入新的元素就会产生移溢出，进而导致程序崩溃。
		在动态分配中，存储数组的空间是在程序执行过程中通过动态分配语句分配的，一旦数据空间占满，就会另外的申请更大的空间。从而达到扩充空间的目的，而不需要为线性表一次性地划分所有空间。
```c++
	#define InitSize 100   //表长度的初始定义
	typedef struct{		
		ElemType *data;  		//指针动态分配数组的指针
		int MaxSize,length;		//数组的最大容量和当前个数
	}SqList;					//动态分配数组顺序表的定义类型
```
	C语言的动态分配语句为：
	L.data=(ElemType *)malloc(sizeof(ElemType) *InitSize);
	C++的初始动态分配语句为：
	L.data=new ElemType[InitSize];

==注意:==动态分配并不是链式存储，他同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。

	下面是总结下顺序结构的特点：
	1.顺序结构最主要的特点是随机访问，及通过首地址和元素序号可在时间O(1)内找到指定的元素。
	2.顺序表的存储密度高，每个节点只存储数据元素
	3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素
### 2.2.2  顺序表上基本操作的实现
	接下来分别给出插入、删除以及按值查找的算法
(1) 插入操作
		在顺序表L的第i(1<=i<=L.length+1)个位置插入新元素额。若i的输入不合法，则返回false，表示插入失败；否则，将顺序表的第i个元素及后面的所有元素右移一个位置，腾出一个空位置插入新元素e,顺序表的长度+1，插入成功，返回true
```c++
	bool ListInsert(SqList &L,int i,ELemType e){
	  	if(i<1||i>L.length+1){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	if(L.length>=MaSize){	 //判断存储空间是否已满
	  		return false; 
	  	}
	  	for(int j=L.length;j>=i;j--){	//将的第i个元素及以后的元素后移
	  		L.data[j]=L.data[j-1];
	  	}
	  	L.data[i-1]=e;	//在位置i出放入e
	  	L.length++;		//线性表长度+1
	  	return true;	  	
	}
```
==注意:==区别顺序表的位序和数组的下标。为何判断插入位置是否合法时if 语句中用length+1，而在移动元素的for语句中只用length？
答案：因为插入可以插入到顺序表的末尾，而整个顺序表中有length个元素，查到最后就是插入第length+1个位置，而在移动元素时，是判断的下标就不是第几个位置了，最后一个元素的下标就是length-1，将最后一个元素后移就是移动到下表为length的位置。大家理解了没？欢迎评论哦！

	下面我们来分析下进行插入操作时的最好情况、最坏情况以及平均情况。
	最好情况：在表尾插入,即i=length+1,元素后移语句将不执行，时间复杂度为O(1)。
	最坏情况：在表头插入,即i=1,元素后移语句执行length次，时间复杂度为O(n)。
	平均情况：假设pi(pi=1/(n+1))是在第i个位置上插入一个节点的概率，则在长度为n的线性表中插入一个节点时，所需移动节点的平均次数为：

![顺序表的平均情况](%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表插入算法的平均复杂度为O(n).

(2) 删除操作
		删除顺序表中第i(1<=i<=L.length) 个位置的元素,若成功则返回true,并将被删除的元素用引用变量e返回,否则返回false。

```c++
	bool ListInsert(SqList &L,int i,ELemType &e){
	  	if(i<1||i>L.length){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	e=L.data[i-1];			//将被删除的元素赋值给e
	  	for(int j=i;j<L.length;j++){	//将的第i个元素后的元素前移
	  		L.data[j-1]=L.data[j];
	  	}
	  	L.length11;		//线性表长度-1
	  	return true;	  	
```

	下面我们来分析下进行删除操作时的最好情况、最坏情况以及平均情况。
	最好情况：删除表尾元素(即i=n),无需移动元素,时间复杂度为O(1)。
	最坏情况：删除表头元素(即i=1),需移动第一个元素以外的所有元素,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是删除第i个位置上节点的概率，则在长度为n的线性表中删除一个节点时,
	所需移动节点的平均次数为：

![删除操作的平均情况](%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表删除算法的平均时间复杂度为O(n)。

		下图为一个顺序表进行插入和删除操作前后的状态，以及其数据元素在存储空间中的位置变化和表长的变化。在a图中，将第4个至第7个元素从后往前依次后移一个位置，在b图中，将第5个至第7个元素依次前移一个位置。

![顺序表的插入和删除](%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4.png)

(3) 按值查找(顺序查找)
在顺序表L中查找第一个元素等于e的元素,并返回其位序。
```c++
	int LocateElem(SqList L,ElemType e){
		int i;
		for(i=0;i<L.length;i++){
			if(L.data[i]==e){
				return i+1;
			}
		}
		return 0;
	}
```

	下面我们来分析下进行按值查找操作时的最好情况、最坏情况以及平均情况。
	最好情况：查找的元素就在表头,仅需比较一次,时间复杂度为O(1)。
	最坏情况：查找的元素在表尾或者不存在,需要比较n次,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是查找的元素在第i(i<=i<=L.length)个位置上的概率，则在长度为n的线性表中查找值为e的元素所需要比较的平均次数为：

![按值查找的平均情况](%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表按值查找算法的平均时间复杂度为O(n).

### 2.2.3  本节习题(选择题我列举几题，综合应用题会全部写出来)
**一、单项选择题**
1.下列(A)是顺序结构的优点。
A.存储密度大          B.插入运算方便
C.删除运算方便         D.方便地运用于各种逻辑结构的存储表示
解析：B和C大家应该都明白吧，至于D选项比如树形结构就不适用于用顺序结构表示更加的适合用链式结构表示。

2.线性表的顺序结构是一种(A)。
A.随机存取的存储结构				B.顺序存取的存储结构
C.索引存取的存储结构				D.元素中各字段的类型
解析：存取是指读写的方式，我们在顺序表的使用过程中显然可以存取任意位置的元素，很多会误选B。

3.若线性表最常用的操作是存取第i个元素以及其前驱和后继元素的值，为了提高效率，应采用(D)的存储方式。
A.单链表                            		    B.双向连表
C.但循环列表								D.顺序表
解析：A.B.C三个选项都只能从头结点依次寻找，时间复杂度为O(n),顺序表可以通过下标直接访问。

4.设线性表有n个元素，严格来说，以下操作中，(C)在顺序表上实现要比链表上实现的效率高。
Ⅰ.输出第i(1<=i<=n)个元素值
Ⅱ.交换第3个元素与第4个元素的值
Ⅲ.顺序输出这n个元素的值
A.Ⅰ    B.Ⅰ、Ⅲ     C.Ⅰ、Ⅱ    D.Ⅱ、Ⅲ
解析：输出第i个元素顺序表可以直接通过下标访问进行输出，对于Ⅱ交换元素这一操作，在链表中要分别找到前驱节点，然后还要进行断链，再次连接起来，而顺序表可以直接进行交换。对于Ⅲ的顺序输出而言，都是一次访问所有的元素，并没有很大的区别。

**二、综合应用题**
1.从顺序表中删除具有最小值的元素(假设唯一)并且由函数返回被删元素的值。空出的位置有最后一个元素填补，若顺序表为空则显示出错误信息并退出运行。

## 2.3线性表的链式表示
		顺序表可以随时存取表中任意一个元素，他的存储位置可以通过一个简单的公式表示，但插入和删除操作需要移动大量元素。链式存储线性表是，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，他通过“链”简历起数据元素之间的逻辑关系，因此插入和删除操作不要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。
### 2.3.1  单链表的定义
		线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身信息外，还需要存放一个指针指向其后继的指针。单链表节点结构如下图，其中data为数据域，存放数据元素；next为指针域，存放其后继节点的地址。

​		![单链表节点结构](%E5%8D%95%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png)

单链表节点类型的描述如下：
```c
	typedof struct LNode{		//定义单链表节点类型
		ElemType data;				//数据域
		struct LNode *next;			//指针域
	}LNode,*LinkList;
```
	单链表的优缺点：
	优点：解决了需要大量连续存储单元的缺点
	缺点:1.是非随机存取的存储结构，不能直接找到表中某个特定的点。
		2.查找某个特定的节点，需要从头遍历，依次查找。


		通常用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长的等信息。头结点的指针域指向线性表的第一个元素结点，如图：

![带头结点的单链表](%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png)
		
		头结点和头指针的区分:不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。
		引入头结点后，可以带来两个优点：
		①由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
		②无论链表是否为空，其头指针都指向结点的飞空指针(空表中头结点的指针域为空),因为空表和飞空表的处理也就得到了统一。
### 2.3.2  单链表上基本操作的实现
1.采用头插法建立单链表
		该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如下图。

![头插法建立单链表](%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.png)

头插法建立单链表的算法如下：
```c
LinkList List_HeadInsert(LinkList &L){	//逆向建立单链表
		LNode *s;int x;
		L=(LinkList)malloc(sizeof(LNode));//创建头结点
		L->next=NULL;					//初始为空链表
		scanf("%d",&x);					//输入结点的值
		while(x!=9999){					//输入9999表示结束
			s=(LNode*)malloc(sizeof(LNode)); //创建新结点
			s->data=x;
			s->next=L>next;
			L->next=s;					//将新结点插入表中，L为头指针
			scanf("%d",&x);
		}
		return L;
}
```
2.采用尾插法建立单链表
		采用尾插发时需要增加一个尾指针r，使其始终指向当前链表的尾结点，如下图：

![尾插法建立单链表](%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.png)

尾插法建立单链表的算法如下：
```c
	LinkedList List_TailInsert(LinkedList &L){//正向建立单链表
		int x;								//设元素类型为整形
		L=(LinkedList)malloc(sizeof(LNode)); 
		LNode *s,*r=L;						//r为表尾指针
		scanf("%d",&x);						//输入结点的值
		while(x!=9999){						//输入9999表示结束
			s=(LNode *)malloc(sizeof(LNode));
			s->data=x;
			r->next=s;
			r=s;						//r指向新的表尾结点
			scanf("%d",&x);
		}
		r->next=NULL;					//尾结点指针置空
		return L;
	}
```
3.按序号查找结点值
		在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。
按序号查找结点值的算法如下：
```c
	LNode *GetElem(LinkLIST L,int i ){
		int j=1;				//计数，初始为1
		LNode *p=L->next;		//头结点指针赋给p
		if(i==0){				
			return L;			//若i==0,在返回头结点
		}
		if(i<1){
			return NULL;		//若i无效，则返回NULL
		}
		while(p&&j<i){			//从第一个结点开始找。查找第i个结点
			p=p->next;
			j++;
		}
		return p;              //返回地i个结点的指针，若i大于表长则返回null
	}
```
4.按值查找表结点
		从链表的第一个结点开始，由前后依次比较表中各结点数据值的值，若某结点数据域的值等于给定值e，则返回该节点的指针；若整个单链中没有做这样的结点，则返回NULL。
按值查找表结点的算法如下：
```c
	LNode *LocateElem(LinkList L,ElemType e){
		LNode *p =L->next;
		while(p_=NULL&&p->data!=e){ // 从第一个结点开始查找data域为e的结点
			p=p->next;
		}
		return p;					//找到后返回该结点指针，否则返回NULL;
	}
```
5.插入结点操作
		插入结点操作讲值为x的新结点插入到单链表的第i个位置上，先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。
		算法要先借助于GetElem(L,i-1),找到第i-1个结点，然后再进行插入操作。
实现插入结点的代码片段如下：
```c
①p=GetElem(L,i-i);    //查找插入位置的前驱节点
②s->next=p->next;     //下图中的步骤1
③p->next=s;			  //下图中的步骤2
```

![单链表的插入操作](%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png)
==注意：==①和②的顺序不能交换。
		扩展：对某一节点进行前插操作：就是在某一个结点前插入一个新结点。
		我们可以采用与后插操作一样的办法，先找到第i-1个结点，在进行插入。但是我们需要再次从头知道找到他的前驱节点。时间复杂度为O(n)
我们也可以采用下面这种方法，利用后插操作，然后交换数据域。从而实现前插的效果。
主要的代码片段

```c
	s->next=p->next;
	p->next=s;
	temp=p->data;
	p->data=s->data;
	s->data=temp;
```
6.删除节点的操作

**欢迎大家留言，持续更新中！！！！！！！**

