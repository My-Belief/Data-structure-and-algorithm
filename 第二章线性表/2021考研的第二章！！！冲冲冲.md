2021考研的第二章！！！冲冲冲

[Toc]
# 第二章  线性表
【考纲的内容】
	（一）线性表的定义和基本操作
	（二）线性表的实现
	（三）顺序存储：链式存储；线性表的应用
【知识框架】
	![](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\知识框架.png)
	
## 2.1 线性表的定义和基本操作
### 2.1.1  线性表的定义
		线性表是具有相同数据类型的n(你>=0)个数据元素的有限序列，其中n为表长，当n=0时，线性表是一个空表。若用L命名线性表，则其一般表示表示为：
			L=(a1,a2,...,ai,a(i+1),...,an)
		式中，a1是唯一的“第一个”数据元素，又称表头元素；an是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素以外，每个元素有且仅有一个直接前驱。除最后一个元素以外，每个元素有且仅有一个直接后驱。根据上述的定义中我们可以得出线性表的如下特点：
	    1.表中元素的个数有限
	    2.表中元素具有逻辑上的顺序性，表中元素有其先后次序
	    3.表中元素都是数据元素，每个元素都是单个元素
	    4.表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间
	    5.表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容
		注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。
### 2.1.2  线性表的基本操作
		一个数据结构的基本操作是指其最核心，最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：
		InitList(&L):初始化表。构建一个空的线性表
		Length(L):求表长。返回线性表L的长度，即L中数据元素的个数
		LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素
		GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值
		ListInsert(&L,i,e):插入操作。在表L中的第i个位置上插入指定元素e
		ListDelete(&L,i,&e):删除操作。输出表L中第i个位置的元素,并用e返回删除的元素
		PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值
		Empty(L):判空操作。若L为空表，则返回true，否则返回false
		DestroyList(&L):销毁操作。毁掉线性表，并释放线性表L所占用的内存空间
## 2.2  线性表的顺序表示
### 2.2.1  顺序表的定义
		线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储子线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第一个元素存储在线性表的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素ai在线性表中的位序。因为，顺序表的特点是表中元素的逻辑顺与其物理顺序相同。
		假设线性表L存储的起始位置为LOC(A),sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序如下图所示：

![线性表的顺序结构](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\线性表的顺序结构.png)
	==注意:==线性表中的元素的位序是从一开始的，而数组中元素的下标谁从0开始的
		
假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：
```c++
	#define MaxSize 50   //定义线性表的最大长度
	typedef struct{		
		ElemType data[MaxSize];  //顺序表的元素
		int length;				//顺序表的长度
	}SqList;					//顺序表的类型定义
```
		在上面的写法中是静态分配的，当然一堆数组也可以动态的进行分配。在静态分配时会产生一些问题，由于数组的大小和空间已经固定。一旦空间占满，再加入新的元素就会产生移溢出，进而导致程序崩溃。
		在动态分配中，存储数组的空间是在程序执行过程中通过动态分配语句分配的，一旦数据空间占满，就会另外的申请更大的空间。从而达到扩充空间的目的，而不需要为线性表一次性地划分所有空间。
```c++
	#define InitSize 100   //表长度的初始定义
	typedef struct{		
		ElemType *data;  		//指针动态分配数组的指针
		int MaxSize,length;		//数组的最大容量和当前个数
	}SqList;					//动态分配数组顺序表的定义类型
```
	C语言的动态分配语句为：
	L.data=(ElemType *)malloc(sizeof(ElemType) *InitSize);
	C++的初始动态分配语句为：
	L.data=new ElemType[InitSize];

==注意:==动态分配并不是链式存储，他同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。

	下面是总结下顺序结构的特点：
	1.顺序结构最主要的特点是随机访问，及通过首地址和元素序号可在时间O(1)内找到指定的元素。
	2.顺序表的存储密度高，每个节点只存储数据元素
	3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素
### 2.2.2  顺序表上基本操作的实现
	接下来分别给出插入、删除以及按值查找的算法
(1) 插入操作
		在顺序表L的第i(1<=i<=L.length+1)个位置插入新元素额。若i的输入不合法，则返回false，表示插入失败；否则，将顺序表的第i个元素及后面的所有元素右移一个位置，腾出一个空位置插入新元素e,顺序表的长度+1，插入成功，返回true
```c++
	bool ListInsert(SqList &L,int i,ELemType e){
	  	if(i<1||i>L.length+1){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	if(L.length>=MaSize){	 //判断存储空间是否已满
	  		return false; 
	  	}
	  	for(int j=L.length;j>=i;j--){	//将的第i个元素及以后的元素后移
	  		L.data[j]=L.data[j-1];
	  	}
	  	L.data[i-1]=e;	//在位置i出放入e
	  	L.length++;		//线性表长度+1
	  	return true;	  	
	}
```
==注意:==区别顺序表的位序和数组的下标。为何判断插入位置是否合法时if 语句中用length+1，而在移动元素的for语句中只用length？
答案：因为插入可以插入到顺序表的末尾，而整个顺序表中有length个元素，查到最后就是插入第length+1个位置，而在移动元素时，是判断的下标就不是第几个位置了，最后一个元素的下标就是length-1，将最后一个元素后移就是移动到下表为length的位置。大家理解了没？欢迎评论哦！

	下面我们来分析下进行插入操作时的最好情况、最坏情况以及平均情况。
	最好情况：在表尾插入,即i=length+1,元素后移语句将不执行，时间复杂度为O(1)。
	最坏情况：在表头插入,即i=1,元素后移语句执行length次，时间复杂度为O(n)。
	平均情况：假设pi(pi=1/(n+1))是在第i个位置上插入一个节点的概率，则在长度为n的线性表中插入一个节点时，所需移动节点的平均次数为：

![顺序表的平均情况](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\顺序表的平均情况.png)

因此，线性表插入算法的平均复杂度为O(n).

(2) 删除操作
		删除顺序表中第i(1<=i<=L.length) 个位置的元素,若成功则返回true,并将被删除的元素用引用变量e返回,否则返回false。

```c++
	bool ListInsert(SqList &L,int i,ELemType &e){
	  	if(i<1||i>L.length){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	e=L.data[i-1];			//将被删除的元素赋值给e
	  	for(int j=i;j<L.length;j++){	//将的第i个元素后的元素前移
	  		L.data[j-1]=L.data[j];
	  	}
	  	L.length11;		//线性表长度-1
	  	return true;	  	
```

	下面我们来分析下进行删除操作时的最好情况、最坏情况以及平均情况。
	最好情况：删除表尾元素(即i=n),无需移动元素,时间复杂度为O(1)。
	最坏情况：删除表头元素(即i=1),需移动第一个元素以外的所有元素,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是删除第i个位置上节点的概率，则在长度为n的线性表中删除一个节点时,
	所需移动节点的平均次数为：

![删除操作的平均情况](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\删除操作的平均情况.png)

因此，线性表删除算法的平均时间复杂度为O(n)。

		下图为一个顺序表进行插入和删除操作前后的状态，以及其数据元素在存储空间中的位置变化和表长的变化。在a图中，将第4个至第7个元素从后往前依次后移一个位置，在b图中，将第5个至第7个元素依次前移一个位置。

![顺序表的插入和删除](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\顺序表的插入和删除.png)

(3) 按值查找(顺序查找)
在顺序表L中查找第一个元素等于e的元素,并返回其位序。
```c++
	int LocateElem(SqList L,ElemType e){
		int i;
		for(i=0;i<L.length;i++){
			if(L.data[i]==e){
				return i+1;
			}
		}
		return 0;
	}
```

	下面我们来分析下进行按值查找操作时的最好情况、最坏情况以及平均情况。
	最好情况：查找的元素就在表头,仅需比较一次,时间复杂度为O(1)。
	最坏情况：查找的元素在表尾或者不存在,需要比较n次,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是查找的元素在第i(i<=i<=L.length)个位置上的概率，则在长度为n的线性表中查找值为e的元素所需要比较的平均次数为：

![按值查找的平均情况](C:\Users\Belief\Desktop\2021考研数据结构\第二章线性表\按值查找的平均情况.png)

因此，线性表按值查找算法的平均时间复杂度为O(n).

### 2.2.3本章习题
==本章的习题会专门写一篇博客说明==



**欢迎大家留言**

