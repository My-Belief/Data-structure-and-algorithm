2021考研的第二章！！！冲冲冲

[Toc]
# 第二章  线性表
【考纲的内容】
	（一）线性表的定义和基本操作
	（二）线性表的实现
	（三）顺序存储：链式存储；线性表的应用
【知识框架】

​	![知识框架](%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6.png)

## 2.1 线性表的定义和基本操作
### 2.1.1  线性表的定义
		线性表是具有相同数据类型的n(你>=0)个数据元素的有限序列，其中n为表长，当n=0时，线性表是一个空表。若用L命名线性表，则其一般表示表示为：
			L=(a1,a2,...,ai,a(i+1),...,an)
		式中，a1是唯一的“第一个”数据元素，又称表头元素；an是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素以外，每个元素有且仅有一个直接前驱。除最后一个元素以外，每个元素有且仅有一个直接后驱。根据上述的定义中我们可以得出线性表的如下特点：
	    1.表中元素的个数有限
	    2.表中元素具有逻辑上的顺序性，表中元素有其先后次序
	    3.表中元素都是数据元素，每个元素都是单个元素
	    4.表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间
	    5.表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容
		注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。

### 2.1.2  线性表的基本操作
		一个数据结构的基本操作是指其最核心，最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：
		InitList(&L):初始化表。构建一个空的线性表
		Length(L):求表长。返回线性表L的长度，即L中数据元素的个数
		LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素
		GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值
		ListInsert(&L,i,e):插入操作。在表L中的第i个位置上插入指定元素e
		ListDelete(&L,i,&e):删除操作。输出表L中第i个位置的元素,并用e返回删除的元素
		PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值
		Empty(L):判空操作。若L为空表，则返回true，否则返回false
		DestroyList(&L):销毁操作。毁掉线性表，并释放线性表L所占用的内存空间
## 2.2  线性表的顺序表示

### 2.2.1  顺序表的定义
		线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储子线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第一个元素存储在线性表的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素ai在线性表中的位序。因为，顺序表的特点是表中元素的逻辑顺与其物理顺序相同。
		假设线性表L存储的起始位置为LOC(A),sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序如下图所示：

![线性表的顺序结构](%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.png)
	==注意:==线性表中的元素的位序是从一开始的，而数组中元素的下标谁从0开始的
		
假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：

```c++
	#define MaxSize 50   //定义线性表的最大长度
	typedef struct{		
		ElemType data[MaxSize];  //顺序表的元素
		int length;				//顺序表的长度
	}SqList;					//顺序表的类型定义
```
		在上面的写法中是静态分配的，当然一堆数组也可以动态的进行分配。在静态分配时会产生一些问题，由于数组的大小和空间已经固定。一旦空间占满，再加入新的元素就会产生移溢出，进而导致程序崩溃。
		在动态分配中，存储数组的空间是在程序执行过程中通过动态分配语句分配的，一旦数据空间占满，就会另外的申请更大的空间。从而达到扩充空间的目的，而不需要为线性表一次性地划分所有空间。
```c++
	#define InitSize 100   //表长度的初始定义
	typedef struct{		
		ElemType *data;  		//指针动态分配数组的指针
		int MaxSize,length;		//数组的最大容量和当前个数
	}SqList;					//动态分配数组顺序表的定义类型
```
	C语言的动态分配语句为：
	L.data=(ElemType *)malloc(sizeof(ElemType) *InitSize);
	C++的初始动态分配语句为：
	L.data=new ElemType[InitSize];

==注意:==动态分配并不是链式存储，他同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。

	下面是总结下顺序结构的特点：
	1.顺序结构最主要的特点是随机访问，及通过首地址和元素序号可在时间O(1)内找到指定的元素。
	2.顺序表的存储密度高，每个节点只存储数据元素
	3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素
### 2.2.2  顺序表上基本操作的实现
	接下来分别给出插入、删除以及按值查找的算法
(1) 插入操作
		在顺序表L的第i(1<=i<=L.length+1)个位置插入新元素额。若i的输入不合法，则返回false，表示插入失败；否则，将顺序表的第i个元素及后面的所有元素右移一个位置，腾出一个空位置插入新元素e,顺序表的长度+1，插入成功，返回true
```c++
	bool ListInsert(SqList &L,int i,ELemType e){
	  	if(i<1||i>L.length+1){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	if(L.length>=MaSize){	 //判断存储空间是否已满
	  		return false; 
	  	}
	  	for(int j=L.length;j>=i;j--){	//将的第i个元素及以后的元素后移
	  		L.data[j]=L.data[j-1];
	  	}
	  	L.data[i-1]=e;	//在位置i出放入e
	  	L.length++;		//线性表长度+1
	  	return true;	  	
	}
```
==注意:==区别顺序表的位序和数组的下标。为何判断插入位置是否合法时if 语句中用length+1，而在移动元素的for语句中只用length？
答案：因为插入可以插入到顺序表的末尾，而整个顺序表中有length个元素，查到最后就是插入第length+1个位置，而在移动元素时，是判断的下标就不是第几个位置了，最后一个元素的下标就是length-1，将最后一个元素后移就是移动到下表为length的位置。大家理解了没？欢迎评论哦！

	下面我们来分析下进行插入操作时的最好情况、最坏情况以及平均情况。
	最好情况：在表尾插入,即i=length+1,元素后移语句将不执行，时间复杂度为O(1)。
	最坏情况：在表头插入,即i=1,元素后移语句执行length次，时间复杂度为O(n)。
	平均情况：假设pi(pi=1/(n+1))是在第i个位置上插入一个节点的概率，则在长度为n的线性表中插入一个节点时，所需移动节点的平均次数为：

![顺序表的平均情况](%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表插入算法的平均复杂度为O(n).

(2) 删除操作
		删除顺序表中第i(1<=i<=L.length) 个位置的元素,若成功则返回true,并将被删除的元素用引用变量e返回,否则返回false。

```c++
	bool ListInsert(SqList &L,int i,ELemType &e){
	  	if(i<1||i>L.length){   //判断i的范围是否有效
	  		return false; 
	  	}
	  	e=L.data[i-1];			//将被删除的元素赋值给e
	  	for(int j=i;j<L.length;j++){	//将的第i个元素后的元素前移
	  		L.data[j-1]=L.data[j];
	  	}
	  	L.length11;		//线性表长度-1
	  	return true;	  	
```

	下面我们来分析下进行删除操作时的最好情况、最坏情况以及平均情况。
	最好情况：删除表尾元素(即i=n),无需移动元素,时间复杂度为O(1)。
	最坏情况：删除表头元素(即i=1),需移动第一个元素以外的所有元素,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是删除第i个位置上节点的概率，则在长度为n的线性表中删除一个节点时,
	所需移动节点的平均次数为：

![删除操作的平均情况](%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表删除算法的平均时间复杂度为O(n)。

		下图为一个顺序表进行插入和删除操作前后的状态，以及其数据元素在存储空间中的位置变化和表长的变化。在a图中，将第4个至第7个元素从后往前依次后移一个位置，在b图中，将第5个至第7个元素依次前移一个位置。

![顺序表的插入和删除](%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4.png)

(3) 按值查找(顺序查找)
在顺序表L中查找第一个元素等于e的元素,并返回其位序。
```c++
	int LocateElem(SqList L,ElemType e){
		int i;
		for(i=0;i<L.length;i++){
			if(L.data[i]==e){
				return i+1;
			}
		}
		return 0;
	}
```

	下面我们来分析下进行按值查找操作时的最好情况、最坏情况以及平均情况。
	最好情况：查找的元素就在表头,仅需比较一次,时间复杂度为O(1)。
	最坏情况：查找的元素在表尾或者不存在,需要比较n次,时间复杂度为O(n)。
	平均情况：假设pi(pi=1/n)是查找的元素在第i(i<=i<=L.length)个位置上的概率，则在长度为n的线性表中查找值为e的元素所需要比较的平均次数为：

![按值查找的平均情况](%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%E7%9A%84%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.png)

因此，线性表按值查找算法的平均时间复杂度为O(n).

### 2.2.3  本节习题(选择题我列举几题，综合应用题会全部写出来)
**一、单项选择题**
1.下列(A)是顺序结构的优点。
A.存储密度大          B.插入运算方便
C.删除运算方便         D.方便地运用于各种逻辑结构的存储表示
解析：B和C大家应该都明白吧，至于D选项比如树形结构就不适用于用顺序结构表示更加的适合用链式结构表示。

2.线性表的顺序结构是一种(A)。
A.随机存取的存储结构				B.顺序存取的存储结构
C.索引存取的存储结构				D.元素中各字段的类型
解析：存取是指读写的方式，我们在顺序表的使用过程中显然可以存取任意位置的元素，很多会误选B。

3.若线性表最常用的操作是存取第i个元素以及其前驱和后继元素的值，为了提高效率，应采用(D)的存储方式。
A.单链表                            		    B.双向连表
C.但循环列表								D.顺序表
解析：A.B.C三个选项都只能从头结点依次寻找，时间复杂度为O(n),顺序表可以通过下标直接访问。

4.设线性表有n个元素，严格来说，以下操作中，(C)在顺序表上实现要比链表上实现的效率高。
Ⅰ.输出第i(1<=i<=n)个元素值
Ⅱ.交换第3个元素与第4个元素的值
Ⅲ.顺序输出这n个元素的值
A.Ⅰ    B.Ⅰ、Ⅲ     C.Ⅰ、Ⅱ    D.Ⅱ、Ⅲ
解析：输出第i个元素顺序表可以直接通过下标访问进行输出，对于Ⅱ交换元素这一操作，在链表中要分别找到前驱节点，然后还要进行断链，再次连接起来，而顺序表可以直接进行交换。对于Ⅲ的顺序输出而言，都是一次访问所有的元素，并没有很大的区别。

**二、综合应用题**
1.从顺序表中删除具有最小值的元素(假设唯一)并且由函数返回被删元素的值。空出的位置有最后一个元素填补，若顺序表为空则显示出错误信息并退出运行。

## 2.3线性表的链式表示
		顺序表可以随时存取表中任意一个元素，他的存储位置可以通过一个简单的公式表示，但插入和删除操作需要移动大量元素。链式存储线性表是，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，他通过“链”简历起数据元素之间的逻辑关系，因此插入和删除操作不要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。
### 2.3.1  单链表的定义
		线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身信息外，还需要存放一个指针指向其后继的指针。单链表节点结构如下图，其中data为数据域，存放数据元素；next为指针域，存放其后继节点的地址。

​		![单链表节点结构](%E5%8D%95%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84.png)

单链表节点类型的描述如下：
```c
	typedof struct LNode{		//定义单链表节点类型
		ElemType data;				//数据域
		struct LNode *next;			//指针域
	}LNode,*LinkList;
```
	单链表的优缺点：
	优点：解决了需要大量连续存储单元的缺点
	缺点:1.是非随机存取的存储结构，不能直接找到表中某个特定的点。
		2.查找某个特定的节点，需要从头遍历，依次查找。


		通常用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长的等信息。头结点的指针域指向线性表的第一个元素结点，如图：

![带头结点的单链表](%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png)
		
		头结点和头指针的区分:不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。
		引入头结点后，可以带来两个优点：
		①由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
		②无论链表是否为空，其头指针都指向结点的飞空指针(空表中头结点的指针域为空),因为空表和飞空表的处理也就得到了统一。
### 2.3.2  单链表上基本操作的实现
1.采用头插法建立单链表
		该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如下图。

![头插法建立单链表](%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.png)

头插法建立单链表的算法如下：
```c
LinkList List_HeadInsert(LinkList &L){	//逆向建立单链表
		LNode *s;int x;
		L=(LinkList)malloc(sizeof(LNode));//创建头结点
		L->next=NULL;					//初始为空链表
		scanf("%d",&x);					//输入结点的值
		while(x!=9999){					//输入9999表示结束
			s=(LNode*)malloc(sizeof(LNode)); //创建新结点
			s->data=x;
			s->next=L>next;
			L->next=s;					//将新结点插入表中，L为头指针
			scanf("%d",&x);
		}
		return L;
}
```
2.采用尾插法建立单链表
		采用尾插发时需要增加一个尾指针r，使其始终指向当前链表的尾结点，如下图：

![尾插法建立单链表](%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8.png)

尾插法建立单链表的算法如下：
```c
	LinkedList List_TailInsert(LinkedList &L){//正向建立单链表
		int x;								//设元素类型为整形
		L=(LinkedList)malloc(sizeof(LNode)); 
		LNode *s,*r=L;						//r为表尾指针
		scanf("%d",&x);						//输入结点的值
		while(x!=9999){						//输入9999表示结束
			s=(LNode *)malloc(sizeof(LNode));
			s->data=x;
			r->next=s;
			r=s;						//r指向新的表尾结点
			scanf("%d",&x);
		}
		r->next=NULL;					//尾结点指针置空
		return L;
	}
```
3.按序号查找结点值
		在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。
按序号查找结点值的算法如下：
```c
	LNode *GetElem(LinkLIST L,int i ){
		int j=1;				//计数，初始为1
		LNode *p=L->next;		//头结点指针赋给p
		if(i==0){				
			return L;			//若i==0,在返回头结点
		}
		if(i<1){
			return NULL;		//若i无效，则返回NULL
		}
		while(p&&j<i){			//从第一个结点开始找。查找第i个结点
			p=p->next;
			j++;
		}
		return p;              //返回地i个结点的指针，若i大于表长则返回null
	}
```
4.按值查找表结点
		从链表的第一个结点开始，由前后依次比较表中各结点数据值的值，若某结点数据域的值等于给定值e，则返回该节点的指针；若整个单链中没有做这样的结点，则返回NULL。
按值查找表结点的算法如下：
```c
	LNode *LocateElem(LinkList L,ElemType e){
		LNode *p =L->next;
		while(p_=NULL&&p->data!=e){ // 从第一个结点开始查找data域为e的结点
			p=p->next;
		}
		return p;					//找到后返回该结点指针，否则返回NULL;
	}
```
5.插入结点操作
		插入结点操作讲值为x的新结点插入到单链表的第i个位置上，先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。
		算法要先借助于GetElem(L,i-1),找到第i-1个结点，然后再进行插入操作。
实现插入结点的代码片段如下：
```c
①p=GetElem(L,i-i);    //查找插入位置的前驱节点
②s->next=p->next;     //下图中的步骤1
③p->next=s;			  //下图中的步骤2
```

![单链表的插入操作](%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png)
==注意：==①和②的顺序不能交换。
		扩展：对某一节点进行前插操作：就是在某一个结点前插入一个新结点。
		我们可以采用与后插操作一样的办法，先找到第i-1个结点，在进行插入。但是我们需要再次从头知道找到他的前驱节点。时间复杂度为O(n)
我们也可以采用下面这种方法，利用后插操作，然后交换数据域。从而实现前插的效果。
主要的代码片段

```c
	//讲啥*s结点插入到*p之前的主要代码片段
	s->next=p->next;		//修改指针域,不能颠倒
	p->next=s;
	temp=p->data;			//交换数据域部分
	p->data=s->data;
	s->data=temp;
```
6.删除节点的操作
		删除节点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除。其操作过程如下图所示：

![单链表结点的删除](%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4.png)
实现删除结点的代码片段如下：
```c
	p=GetElem(L,i-1);		//查找删除位置的前驱结点，时间复杂度为O(n)
	q=p->next;				//令q指向被删除的结点
	p->next=q->next;		//将*q结点从链中断开
	free(q);				//释放结点的存储空间
```
		扩展：删除结点*p
		要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作，算法的时间复杂度为O(n).
		其实，删除结点*p的操作可用删除*p的后继结点来实现，实质就是将其后继节点的值赋予自身，善后删除后继结点，也能使得时间复杂度为O(1).
实现上述操作的代码片段如下：
```c
	q=->next;			//令q指向*p的后继结点
	p->data=p->next->data;	//和后继结点交换数据域
	p->next=q->next;		//将*q结点从链中断开
	free(q);			//释放后继站点的存储空间
```
7.求表长操作

		求表长操作就是计算单链表中数据结点(不含头结点的个数)，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空节点为止。算法的事件复杂度为O(n)。
		需要注意的是,因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。
### 2.3.3  双链表
		单链表结点中只有一个指向其后继的指针，是的单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时),只能从头开始遍历，访问后继结点的事件复杂度为O(1),访问前驱结点的事件复杂度为O(n)。
		为了克服以上单链表的缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点，如下图：

![双链表示意图](%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
双链表中结点类型的描述如下：
```c
	typedef struct DNode{			//定义双链表结点类型
			ElemType data;			//数据域
			struct DNode *prior,*next;	//前驱和后驱指针
	}DNode,*DLinklist;
```
		双链表在单链表的结点中增加了一个指向前驱的prior指针，因此双链表中的按值查找和按位查找的操作与单链表相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为链变化是也需要对prior指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的事件复杂度仅为O(1)。
1.双链表的插入操作
在双链表中p所指的结点之后插入结点*s,其指针的变化过程如图所示：

![双链表插入结点过程](%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png)
插入操作的代码片段如下：
```c
	s->next=p->next;		//将结点*s插入到结点*p之后
	p->next->prior=s;
	s->prior=p;
	p->next=s;
```
2.双链表的删除操作
删除双链表中结点*p的后继结点*q，其指针的变化过程如图：

![双链表删除结点过程](%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E8%BF%87%E7%A8%8B.png)
删除操作的代码片段如下：
```c
	p->next=q->next;   //图中1步骤
	q->next->prior=p;	//途中2步骤
	free(q);			//释放结点空间
```
		在建立双链表的操作中，也可以采用如同单链表的头插法和尾插法，但在操作上需要注意指针的变化和单链表有所不同。
### 2.3.4  循环链表
1.循环单链表
		循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环，如图所示。

![循环单链表](%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8.png)
		在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域我NULL的结点，因此，判断循环单链表是否为空的条件是头结点的next域知否指向头结点
		循环单链表的、删除算法域单链表几乎一样，唯一不同就是在表尾进行操作。因为是循环链表所以在哪里插入都是一样的。循环单链表可以在任意位置开始遍历而单链表智能从头结点开始遍历。
2.循环双链表
		由循环列表的定义不难退出循环双列表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如图所示：
![循环双链表](%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8.png)

在循环双链表L中，某结点*p为尾结点时，p->next=L；当循环双链表为空表时，其头结点的prior域和next域都等于L。
### 2.3.5  静态链表
		静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，和链表中的指针不同的是，静态链表中的指针是结点的相对地址(数组下标),又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。

静态链表和单链表的对应关系如图：

![带头结点的单链表](%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png)
静态链表结构类型的描述如下：
```c
	#define MaxSize 50		//静态链表的最大长度
	typedef struct{			//静态链表结构类型的定义
		ElemType data；		//存储数据元素
		int next;			//下一个元素的数组下标
	}SLinkList{MaxSize};
```
		静态链表以next==-1作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言(如Basic)中，这是一种十分巧妙的设计方法。
### 2.3.6  顺序表和链表的比较
1.存取(读写)方式
		顺序表可以顺序获取，也可以随机获取，链表只能从表头顺序获取元素。例如在第i个位
置上执行存或取的操作，顺序表仅需一次访问，而链表则需从头开始依次访问i次.
2.逻辑结构与物理结构
		采用顺序结构是，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储是，逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的。
3.查找、插入和删除操作
		对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找。此时的时间复杂度为O(log~2~n)。
		对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1),而链表的平均时间复杂度为O(n),顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。
4.空间分配
		顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若在加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量
闲置；预先分配过小，又会造成内存溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大快的连续存储空间，则会导致分配失效。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。

==在实际中应该怎么选取存储结构？==
1.基于存储的考虑
		难以估计线性表的长度或存取规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。
2.基于运算的考虑
		在顺序表中按序号访问a~i~的时间复杂度为O(1)，而链表中按序号访问的事件复杂度为O(n),因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。如果经常使用删除、插入等操作，则链表的优先级高于顺序表。
3.基于环境的考虑
		顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，顺序表实现较为简单。

### 2.3.7 本节习题
1.给定有n个元素的一堆数组，简历一个有序单链表的最低时间复杂度是(D)
A.O(1)		B.O(n)		C.O(n^2^)		D.O(blog~2~n)
解析：若先建立链表，然后依次插入建立有序表，则每插入一个元素就需要遍历链表寻找插入位置，即直接插入排序，时间复杂度为O(n^2^).若先将数组排序好，然后建立链表，建立链表的时间复杂度为O(n),数组排序的最好时间复杂度为O(nlog~2~n).故选D。

2.将长度为n的单链表链接在长度为m的单链表后面，其算法的时间复杂度采用大O形式应该是(C)
A.O(1)		B.(n)		C.(m)		D.(n+m)		
解析：先遍历长度为m的单链表，找到该单链表的尾结点，然后将其next域指向另一个单链表的首节点，其时间复杂度为O(m).

3.在一个长度为n的带头结点的单链表h上，设有尾指针r，则执行(B)操作与链表的表长有关。
A.删除单链表中的第一个元素
B.删除单链表中最后一个元素
C.在单链表第一个元素前插入一个新元素
D.在单链表最后一个元素后插入一个新元素
解析：删除单链表的最后一个结点需置其前驱结点的指针域为NULL，需要从头开始依次遍历找到该前驱结点，需要O(n)的时间，与表长有关。其他操作均与表长无关。

4.在长度为n的有序单链表中插入一个新结点，并任然保持有序的时间复杂度是(B)
A.O(1)		B.O(n)		C.(n^2^)		D.(nlog~2~n)
解析：假设单链表是依次递增的，首先我们要找到第一个大于x的结点的直接前驱结点p，在p之后插入该结点。查找的时间复杂度为O(n),插入的时间复杂度为O(1),总时间复杂度为O(n).

5.已知表头元素为c的单链表在内存中的单元存储状态如下表所示：
![2016统考真题23](2016%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%9823.png)
现将f存放于1014H处并插入单链表，ruof在逻辑上位于a和e之间，则a，e，f的“链接地址”
依次是(D)
A.1010H,1014H,1004H				B.1010H,1004H,1014H
C.1014H,1010H,1004H				D.1014H,1004H,1010H
解析：连接地址是指的next域所指的内存地址我们按照顺序afe写出出来即可，就是1014H,1004H,1010H

6.某线性表用带头结点的循环单链表存储，头指针为head，当head->next->next=head成立时，线性表的长度可能是(D)
A.0		B.1		C.2		D.可能为0或1
解析：对一个空循环单链表。有head->next==head,则head->next->next=head也成立。对含有一个元素的循环单链表head->next->next=head也成立。

二、综合运用题

**欢迎大家留言，持续更新中！！！！！！！**

